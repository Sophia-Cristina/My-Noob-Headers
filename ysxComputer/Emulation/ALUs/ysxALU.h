#pragma once

#ifndef YSXALU_H
#define YSXALU_H
//#include <time.h>

// #####################
// ####### By Sophia Cristina
// ####### I'm trying to study some computer stuffs...
// #######
// ####### ALU emulation goes here AND NOT on the include:
// ####### "ysxComp/ysxEMU.h"
// ####### ALU electrical components goes on the include:
// ####### "ysxplg/ysxElectr.h"
// #######
// #####################

// #################################################
// #################################################
// #################################################


// ###############################################################################################################################################################################
// ###############################################################################################################################################################################
// ###############################################################################################################################################################################

// #################################################
// ############## ADDER ##############

// INPUT AB.x = A, AB.y = B, OUTPUT, .x = S, .y = C:
// Prefer to use same size for all objects!
void HalfAdder(Point<std::vector<uint8_t>> AB, uint8_t* S, uint8_t* C)
{
	unsigned int Size = 0; AB.x.size() <= AB.y.size() ? Size = AB.x.size() : Size = AB.y.size();
	for (size_t n = 0; n < Size; ++n) { S[n] = AB.x[n] ^ AB.y[n]; C[n] = AB.x[n] & AB.y[n]; }
}

// INPUT ABC.x = A, ABC.y = B, ABC.z = C_in, OUTPUT, .x = S, .y = C_out:
// Prefer to use same size for all objects!
void FullAdder(Point3D<std::vector<uint8_t>> ABC, uint8_t* S, uint8_t* C)
{
	unsigned int Size = 0;
	ABC.x.size() <= ABC.y.size() ? Size = ABC.x.size() : Size = ABC.y.size();
	if (ABC.z.size() < Size) { Size = ABC.z.size(); }
	for (size_t n = 0; n < Size; ++n)
	{
		uint8_t XOR = (ABC.x[n] ^ ABC.y[n]);
		S[n] = XOR ^ ABC.z[n]; C[n] = (ABC.x[n] & ABC.y[n]) | (XOR & ABC.z[n]);
	}
}

// ###############################################################################################################################################################################
// ####### MAIN #################################################################################################################################################################
// ###############################################################################################################################################################################

#endif // SCPARSE_