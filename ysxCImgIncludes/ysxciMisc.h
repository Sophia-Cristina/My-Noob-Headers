#pragma once

#ifndef YSXCIMISC_H
#define YSXCIMISC_H

using namespace cimg_library;

// ###################################
// ############## FUNÇÕES #######
// ###################################
// ############## DECLARAÇÕES:



// ###################################

// ############################################################################################################################################
// ############################################################################################################################################
// ############################################################################################################################################

// ############################################################################################################################################
// ############## MODULAÇÕES COM HUE:
CImg<uint8_t> PaintHueRGBGapMod(CImg<uint8_t> I, double Phase, double Omega, int R0, int R1, int G0, int G1, int B0, int B1)
{
	std::vector<Pixel> VP = BitmapPixelMatrix(I);
	for (int n = 0; n < VP.size(); ++n)
	{
		if (InsideRGBGap(VP[n].RGB, R0, R1, G0, G1, B0, B1))
		{
			double Hue = ModForm(((double)n / VP.size() * TAU) + Phase, Omega);
			Point3D<uint8_t> C = LinearRGB(Hue, 1, 1);
			uint8_t UC[] = { C.x, C.y, C.z };
			I.draw_point(VP[n].x, VP[n].y, UC);
		}
	}
	return(I);
}

// ############################################################################################################################################
// ############################################################################################################################################
// ############################################################################################################################################


// ################################################# FIM ####################################################################################

#endif // SCPARSE_